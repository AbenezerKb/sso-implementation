image: golang:1.18

variables:
  TAG: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_NAME:$CI_PIPELINE_ID

.go-cache:
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  before_script:
    - mkdir -p .go
  cache:
    paths:
      - .go/pkg/mod/

stages:
  - test
  - setup
  - publish
  - deploy
test:
  extends: .go-cache
  stage: test
  services:
    - redis:latest
    - name: cockroachdb/cockroach:latest
      alias: db
      command: ["start-single-node", "--insecure"]
    - name: bitnami/zookeeper:3.8
      alias: zookeeper
    - name: bitnami/kafka:3.3
      alias: kafka
  variables:
    FF_NETWORK_PER_BUILD: 1
    KAFKA_BROKER_ID: 1
    KAFKA_CFG_LISTENERS: "PLAINTEXT://:9092"
    KAFKA_CFG_ADVERTISED_LISTENERS: "PLAINTEXT://kafka:9092"
    KAFKA_CFG_ZOOKEEPER_CONNECT: "zookeeper:2181"
    ALLOW_PLAINTEXT_LISTENER: "yes"
    ALLOW_ANONYMOUS_LOGIN: "yes"
    KAFKA_CREATE_TOPICS: "example-topic"
    KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
  tags:
    - sso
  before_script:
    - apt update && apt install openssh-client
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - echo "$SSH_ACCESS_KEY" | tr -d '\r' | ssh-add -
    - chmod 700 ~/.ssh
    - ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - go env -w GOPRIVATE="gitlab.com/2ftimeplc/*"
    - printf "machine gitlab.com\nlogin 2ftimesgitlab@gmail.com\npassword $ACCESS_TOKEN" > ~/.netrc
    - printf '[user]\n\temail = 2ftimesgitlab@gmail.com\n\tname = Two F Times Trading PLC\n\n[url "ssh://git@gitlab.com/"]\n\tinsteadOf = https://gitlab.com/' > ~/.gitconfig

  script:
    - CONFIG_NAME=$CONFIG_NAME go test ./... -count=1
  except:
    - pre-production
    - production

install_dependencies:
  stage: setup
  image: golang:1.19.3-alpine3.16
  tags:
    - sso
  before_script:
    - mkdir -p .go
    - apk update && apk add openssh-client
    - apk add git
    - eval $(ssh-agent -s)
    - mkdir -p ~/.ssh
    - echo "$SSH_ACCESS_KEY" | tr -d '\r' | ssh-add -
    - chmod 700 ~/.ssh
    - ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
    - go env -w GOPRIVATE="gitlab.com/2ftimeplc/*"
    - printf "machine gitlab.com\nlogin 2ftimesgitlab@gmail.com\npassword $ACCESS_TOKEN" > ~/.netrc
    - printf '[user]\n\temail = 2ftimesgitlab@gmail.com\n\tname = Two F Times Trading PLC\n\n[url "ssh://git@gitlab.com/"]\n\tinsteadOf = https://gitlab.com/' > ~/.gitconfig
  script:
    - go mod vendor
  cache:
    key: $CI_PROJECT_DIR
    paths:
      - vendor/
    policy: push
  only:
    changes:
      - go.mod
      - go.sum
    refs:
      - main
      - staging
      - pre-production
      - production

publish:
  image: docker:latest
  stage: publish
  cache:
    key: $CI_PROJECT_DIR
    paths:
      - vendor/
    policy: pull
  tags:
    - sso
  services:
    - docker:dind
  script:
    - docker build -t $TAG .
    - docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY
    - docker push $TAG
    - docker rmi -f $(docker images --filter "dangling=true" -q --no-trunc) || clean_up_status=$?
  only:
    refs:
      - main
      - staging
      - pre-production
      - production

deploy-for-main:
  image: alpine:latest
  stage: deploy
  tags:
    - sso
  before_script:
    - apk update && apk add openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVERIP_MAIN >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - ssh $SERVERUSER_MAIN@$SERVERIP_MAIN "docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY"
    - ssh $SERVERUSER_MAIN@$SERVERIP_MAIN "docker pull $TAG"
    - ssh $SERVERUSER_MAIN@$SERVERIP_MAIN "docker service update --image $TAG --force sso_sso"

  only:
    refs:
      - main

deploy-for-staging:
  image: alpine:latest
  stage: deploy
  tags:
    - sso
  before_script:
    - apk update && apk add openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVERIP_STAGING >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - ssh $SERVERUSER_STAGING@$SERVERIP_STAGING "docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY"
    - ssh $SERVERUSER_STAGING@$SERVERIP_STAGING "docker pull $TAG"
    - ssh $SERVERUSER_STAGING@$SERVERIP_STAGING "docker service update --force sso_sso"

  only:
    refs:
      - staging
deploy-for-pre-production:
  image: alpine:latest
  stage: deploy
  tags:
    - sso
  before_script:
    - apk update && apk add openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVERIP_PRE_PRODUCTION >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - ssh $SERVERUSER_PRE_PRODUCTION@$SERVERIP_PRE_PRODUCTION "docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY"
    - ssh $SERVERUSER_PRE_PRODUCTION@$SERVERIP_PRE_PRODUCTION "docker pull $TAG"
    - ssh $SERVERUSER_PRE_PRODUCTION@$SERVERIP_PRE_PRODUCTION "docker service update --force sso_sso"

  only:
    refs:
      - pre-production
deploy-for-production:
  image: alpine:latest
  stage: deploy
  tags:
    - sso
  before_script:
    - apk update && apk add openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVERIP_PRODUCTION >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts

  script:
    - ssh $SERVERUSER_PRODUCTION@$SERVERIP_PRODUCTION "docker login -u gitlab-ci-token -p $CI_BUILD_TOKEN $CI_REGISTRY"
    - ssh $SERVERUSER_PRODUCTION@$SERVERIP_PRODUCTION "docker pull $TAG"
    - ssh $SERVERUSER_PRODUCTION@$SERVERIP_PRODUCTION "docker service update --force sso_sso"

  only:
    refs:
      - production
